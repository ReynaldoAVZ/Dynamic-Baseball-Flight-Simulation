%%%%%%%%%%%%%%%%%%%%%%%%%% ME EN 2030 Dynamics %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% mfile to calculate the coefficient of resitution from bat velocity  %%%
%%% and ball speed data collected through an accelerometer.  Several    %%%
%%% lines below must be completed for the function to run including     %%%
%%% specified parameters on lines 16,17, and 18 (see also 11,12,13 that %%%
%%% have representative values) and formulations/equations on lines     %%%
%%% 22,23,35,36,41,42, and 48. You also must specify either a full or   %%%
%%% relative file path (line 12).                                       %%%
%%%%%%%%%%%%%%%%%%%%%%% Version date: 4/17/2023 %%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clear,clc,close all
DataPath = 'Villarreal7.txt';
g = 9.8; %[m/s^2] value for gravity
Bat_L = 33*0.0254; %[convert inch. to meter] bat length in meters
L_I = 2/3; %[unitless] estimated fraction of bat length to the impact point

%input data on ball exit speed:
V_bo = 68/2.237;%??; %ball exit speed from Pocket Radar [make sure units are correct]
theta_o = 40;%??; %ball launch angle from bat [educated guess base on obs.]
offset = .0318;%??; %offset during impact between the ball and bat centers of gravity [educated guess base on obs.]

%here you should convert V_bo into its components using theta_o (AI=after impact)
U_ball_AI = V_bo*sind(theta_o);%??;
V_ball_AI = V_bo*cosd(theta_o);%??;

%retrieve data from the accelerometer sensor file [U,V,W in m/s and wx,wy,wz in rad/s]
[Uout,Vout,Wout,wxout,wyout,wzout] = get_VelfromAccel(DataPath,g,true);

%U,V,W are at the bat handle, not the impact point.  Note that W will be 
%aligned with the bat and therefore doesn't contribute to ball flight and 
%therefore doesn't need to be translated to the impact point.  

%Translate Velocity to the impact point here 
% (will require Bat_L and L_I from above plus other variables):
U_bat_impact = (Uout + wxout*Bat_L*L_I); %+/- ??;
V_bat_impact = (Vout + wyout*Bat_L*L_I); %+/- ??;

%You will also need to make an educated guess on the bat velocity
%components after the impact event.  This could be retrieved from data but
%is difficult.  Likely these should be function of U_bat_impact and V_bat_impact
U_bat_AI = U_bat_impact;%??;
V_bat_AI = V_bat_impact*7/8;%??;

%At this stage you will have all the pieces to calculate the coefficient of
%restitution.  Remember that you need to rotate your velocities relative to
%the impact plane.  This will be a function of your impact offset.

epsilon = abs((V_bat_AI - V_ball_AI)/V_bat_impact);

%Display the result on the command line
disp('----- Coefficient of restitution for ball-bat collision -----')
disp(['epsilon = ',num2str(epsilon)])
disp('-------------------------------------------------------------')

%%%%%%%%%%%%%%%%%%%%%%%%%% ME EN 2030 Dynamics %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Function to calculate 3D velocity from 3D acceration data from an   %%%
%%% accelerometer.  The input is the relative path (relative to the     %%%
%%% to the location the function is called from), the value of gravity, %%%
%%% and plotting option (set to >>true or >>false) and the outputs are  %%%
%%% the U,V, and W components of the velocity and the x,y, and z        %%%
%%% components of the angular velocity at 'impact'.                     %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [Uout,Vout,Wout,wxout,wyout,wzout] = get_VelfromAccel(DataPath,g,opt)

%filter parameters (smooth the signal if desired, larger windowSize => more filtering)
windowSize = 5; %number of data points to smooth over
maxdt = seconds(5); %sensors min sample rate is 0.2hz, any dt larger is bogus

%load the full data
DataTable = importfile(DataPath); %function below generated by matlab

%parce out the data we need from the table
%calculate the average resolution (timestep) of the timeseries
times=DataTable.VarName1(~isnat(DataTable.VarName1));
%sometimes the first record is wrong so kill it if it is
if(times(2)-times(1)>maxdt)
    DataTable.VarName1(1)=NaT; %set the 'bad' data to Not a Time
    %re-read the time data with the scrubbed point
    times=DataTable.VarName1(~isnat(DataTable.VarName1));
end

times=seconds(times-times(1));%remove date/hour info
dt = times(end)/length(times);

%set the filter window constants (using a 'box filter', e.g. local average)
b = (1/windowSize)*ones(1,windowSize);
a = 1;

Ax = filter(b,a,DataTable.VarName3(~isnat(DataTable.VarName1)));
Ay = filter(b,a,DataTable.VarName4(~isnat(DataTable.VarName1)));
Az = filter(b,a,DataTable.VarName5(~isnat(DataTable.VarName1)));

wx = filter(b,a,DataTable.VarName13(~isnat(DataTable.VarName1)))*pi/180;
wy = filter(b,a,DataTable.VarName14(~isnat(DataTable.VarName1)))*pi/180;
wz = filter(b,a,DataTable.VarName15(~isnat(DataTable.VarName1)))*pi/180;

%must remove gravity!
roll = filter(b,a,DataTable.VarName17(~isnat(DataTable.VarName1)));
pitch = filter(b,a,DataTable.VarName18(~isnat(DataTable.VarName1)));
yaw = filter(b,a,DataTable.VarName19(~isnat(DataTable.VarName1)));

for i=1:length(roll)
    g_rot = rotateGravitationalVector(roll(i), pitch(i),yaw(i));
    Ax(i)=Ax(i)-g_rot(1);
    Ay(i)=Ay(i)-g_rot(2);
    Az(i)=Az(i)+g_rot(3);
end
% find index (time) of peak accel
[~,ia] = max(sqrt(Ax.^2+Ay.^2+Az.^2));

% calculate velocity from acceleration at bat handle (2.23... converts m/s to mph)
U = cumtrapz(Ax)*dt*g*2.23694; %[mph]
V = cumtrapz(Ay)*dt*g*2.23694; %[mph]
W = cumtrapz(Az)*dt*g*2.23694; %[mph]

Uout = U(ia);
Vout = V(ia);
Wout = W(ia);

wxout = wx(ia);
wyout = wy(ia);
wzout = wz(ia);

if(opt)%optional plotting and output from the function (send true to plot)
    disp('------- Velocity of the bat handle -------')
    disp(['max U = ',num2str(U(ia)),' mph'])
    disp(['max V = ',num2str(V(ia)),' mph'])
    disp(['max W = ',num2str(W(ia)),' mph'])
    disp(['max |U| = ',num2str(sqrt(U(ia)^2+V(ia)^2)),' mph'])
    disp('------------------------------------------')

    figure;plot(times,roll,times,pitch,times,yaw,'LineWidth',2);
    legend('Roll','Pitch','Yaw')
    xlabel('seconds');ylabel('angle (degrees)');set(gca,'FontSize',12)

    figure;plot(times,Ax,times,Ay,times,Az,times,sqrt(Ax.^2+Ay.^2+Az.^2),'LineWidth',2);
    legend('X accel','Y accel','Z accel','Magnitude')
    xlabel('seconds');ylabel('accel (g)');set(gca,'FontSize',12)

    figure;plot(times,wx,times,wy,times,wz,'LineWidth',2);
    legend('\omega_X','\omega_Y','\omega_Z')
    xlabel('seconds');ylabel('angular velocity (rad/sec)');set(gca,'FontSize',12)

    figure;plot(times,U,'LineWidth',2);hold on;plot(times,V,'LineWidth',2);
    plot(times,W,'LineWidth',2);plot(times,sqrt(U.^2+V.^2),'LineWidth',2)
    legend('U velocity','V velocity','W velocity','Magnitude')
    xlabel('seconds');ylabel('velocity (mph)');set(gca,'FontSize',12)
end

end

%%% Matlab function generated by import 'wizard' for specific data file %%%
%%% format                                                              %%%
function DataTable = importfile(filename, dataLines)
%IMPORTFILE Import data from a text file
%  DataTable = IMPORTFILE(FILENAME) reads data from text file
%  FILENAME for the default selection.  Returns the data as a table.
%
%  DataTable = IMPORTFILE(FILE, DATALINES) reads data for the
%  specified row interval(s) of text file FILENAME. Specify DATALINES as
%  a positive scalar integer or a N-by-2 array of positive scalar
%  integers for dis-contiguous row intervals.
%
%  Example:
%  DataTable = importfile("ME2030/Project/Record154311.txt", [1, Inf]);
%
%  See also READTABLE.
%
%% Input handling

% If dataLines is not specified, define defaults
if nargin < 2
    dataLines = [1, Inf];
end

%% Set up the Import Options and import the data
opts = delimitedTextImportOptions("NumVariables", 19);

% Specify range and delimiter
opts.DataLines = dataLines;
opts.Delimiter = ",";

% Specify column names and types
opts.VariableNames = ["VarName1", "a", "VarName3", "VarName4", "VarName5", "ver", "VarName7", "eq", "VarName9", "rssi", "VarName11", "w", "VarName13", "VarName14", "VarName15", "Angle", "VarName17", "VarName18", "VarName19"];
opts.VariableTypes = ["datetime", "categorical", "double", "double", "double", "categorical", "double", "categorical", "double", "categorical", "double", "categorical", "double", "double", "double", "categorical", "double", "double", "double"];

% Specify file level properties
opts.ExtraColumnsRule = "ignore";
opts.EmptyLineRule = "read";

% Specify variable properties
opts = setvaropts(opts, ["a", "ver", "eq", "rssi", "w", "Angle"], "EmptyFieldRule", "auto");
opts = setvaropts(opts, "VarName1", "InputFormat", "yyyy-MM-dd HH:mm:ss.SSS");

% Import the data
DataTable = readtable(filename, opts);

end

function g_rot = rotateGravitationalVector(roll,pitch,yaw)
%ROTATEGRAVITATIONALVECTOR Rotates the gravitational vector into the
%   direction of the given pitch, yaw, and roll angles with respect to the
%   earth.
%
%   The input angles should be specified in degrees, as follows:
%     roll : rotation angle about the x-axis (positive roll tilts the
%            sensor to the right)
%     pitch: rotation angle about the y-axis (positive pitch tilts the
%            nose of the sensor downwards)
%     yaw  : rotation angle about the z-axis (positive rotation rotates 
%            the sensor CCW)
%
%   The output vector g_rot is the rotated gravitational vector, which
%   points in the direction of the given roll, pitch, and yaw angles.

% Define the gravitational vector in the Earth frame
g_earth = [0; 0; -1]; % normalized acceleration due to gravity

% Convert the input angles from degrees to radians
pitch = deg2rad(pitch);
roll = deg2rad(roll);
yaw = deg2rad(yaw);

% Define the rotation matrices for each angle
R_x = [1 0         0;
       0 cos(roll) -sin(roll);
       0 sin(roll) cos(roll)];

R_y = [cos(pitch)  0 sin(pitch);
       0           1 0;
      -sin(pitch)  0 cos(pitch)];

R_z = [cos(yaw)  -sin(yaw) 0;
       sin(yaw)  cos(yaw)  0;
       0         0         1];

% Compute the overall rotation matrix
R = R_x * R_y * R_z;
% Compute the rotated gravitational vector
g_rot = R * g_earth;
end